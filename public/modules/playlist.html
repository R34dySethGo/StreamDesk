<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Music Control</title>
  
  <!-- ==========================================
       MODULE CONFIGURATION
       ========================================== -->
  <script type="application/json" id="module-config">
  {
    "id": "playlist",
    "name": "Music",
    "priority": 3,
    "borderColor": "#0d5c1f",
    "activeColor": "#1DB954",
    "hasControllerUI": true,
    "hasOverlay": false,
    "dependencies": [],
    "musicModule": true
  }
  </script>
  
  <!-- ==========================================
       SERVER MODULE CODE
       ========================================== -->
  <script type="text/x-server-module">
// Initialize playlist state
if (!moduleStates.playlist) {
  moduleStates.playlist = {
    songs: [],
    currentIndex: 0,
    isPlaying: false,
    volume: 50,
    previousVolume: 50,
    targetVolume: 50,
    fadeStartTime: null,
    fadeDirection: null,
    isShuffled: false,
    shuffledIndices: [],
    currentSongMetadata: null
  };
}

const playlistState = moduleStates.playlist;

// Fade duration in milliseconds
const FADE_DURATION = 2000;

// Volume fade interpolation
function getCurrentVolume() {
  if (!playlistState.fadeStartTime) {
    return playlistState.volume;
  }
  
  const elapsed = Date.now() - playlistState.fadeStartTime;
  if (elapsed >= FADE_DURATION) {
    playlistState.volume = playlistState.targetVolume;
    playlistState.fadeStartTime = null;
    playlistState.fadeDirection = null;
    return playlistState.volume;
  }
  
  const progress = elapsed / FADE_DURATION;
  const start = playlistState.previousVolume;
  const end = playlistState.targetVolume;
  
  playlistState.volume = Math.round(start + (end - start) * progress);
  return playlistState.volume;
}

// Load songs from /public/music/ folder
function loadSongs() {
  const musicDir = path.join(__dirname, 'public', 'music');
  
  if (!fs.existsSync(musicDir)) {
    fs.mkdirSync(musicDir, { recursive: true });
    console.log('[PLAYLIST] Created /public/music/ folder');
    return [];
  }
  
  const files = fs.readdirSync(musicDir);
  const songs = files.filter(f => 
    f.toLowerCase().endsWith('.mp3') || 
    f.toLowerCase().endsWith('.wav') || 
    f.toLowerCase().endsWith('.ogg')
  );
  
  console.log(`[PLAYLIST] Found ${songs.length} songs`);
  return songs;
}

// Generate shuffled indices
function generateShuffledIndices(length) {
  const indices = Array.from({ length }, (_, i) => i);
  
  // Fisher-Yates shuffle
  for (let i = indices.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [indices[i], indices[j]] = [indices[j], indices[i]];
  }
  
  return indices;
}

// Extract metadata from filename
function extractMetadata(filename) {
  const nameWithoutExt = filename.replace(/\.(mp3|wav|ogg)$/i, '');
  
  // Try to parse "Artist - Title" format
  if (nameWithoutExt.includes(' - ')) {
    const parts = nameWithoutExt.split(' - ');
    const artist = parts[0].trim();
    const title = parts.slice(1).join(' - ').trim();
    
    // Check for cover image
    const musicDir = path.join(__dirname, 'public', 'music');
    const baseName = filename.replace(/\.(mp3|wav|ogg)$/i, '');
    let coverUrl = null;
    
    const possibleCovers = [
      `${baseName}.jpg`,
      `${baseName}.jpeg`,
      `${baseName}.png`,
      `${baseName}.webp`
    ];
    
    for (const coverFile of possibleCovers) {
      if (fs.existsSync(path.join(musicDir, coverFile))) {
        coverUrl = `/music/${coverFile}`;
        break;
      }
    }
    
    return {
      artist: artist,
      title: title,
      filename: filename,
      coverUrl: coverUrl
    };
  }
  
  return {
    artist: 'Unknown Artist',
    title: nameWithoutExt,
    filename: filename,
    coverUrl: null
  };
}

// Routes
app.get('/api/playlist/songs', getUserFromSession, (req, res) => {
  playlistState.songs = loadSongs();
  res.json({ songs: playlistState.songs });
});

app.get('/api/playlist/state', getUserFromSession, (req, res) => {
  const currentSong = playlistState.songs[playlistState.currentIndex];
  const metadata = currentSong ? extractMetadata(currentSong) : null;
  const currentVol = getCurrentVolume();
  
  res.json({
    currentIndex: playlistState.currentIndex,
    currentSong: currentSong || null,
    metadata: metadata,
    isPlaying: playlistState.isPlaying,
    volume: currentVol,
    previousVolume: playlistState.previousVolume,
    targetVolume: playlistState.targetVolume,
    isFading: playlistState.fadeStartTime !== null,
    isShuffled: playlistState.isShuffled,
    totalSongs: playlistState.songs.length
  });
});

app.get('/api/playlist/public', (req, res) => {
  const currentSong = playlistState.songs[playlistState.currentIndex];
  const metadata = currentSong ? extractMetadata(currentSong) : null;
  const currentVol = getCurrentVolume();
  
  res.json({
    currentIndex: playlistState.currentIndex,
    currentSong: currentSong || null,
    metadata: metadata,
    isPlaying: playlistState.isPlaying,
    volume: currentVol,
    isFading: playlistState.fadeStartTime !== null,
    totalSongs: playlistState.songs.length
  });
});

app.post('/api/playlist/playpause', getUserFromSession, (req, res) => {
  playlistState.isPlaying = !playlistState.isPlaying;
  console.log(`[PLAYLIST] ${playlistState.isPlaying ? 'Playing' : 'Paused'}`);
  res.json({ isPlaying: playlistState.isPlaying });
});

app.post('/api/playlist/skip', getUserFromSession, (req, res) => {
  if (playlistState.songs.length === 0) {
    return res.status(400).json({ error: 'No songs available' });
  }
  
  if (playlistState.isShuffled) {
    const currentShufflePos = playlistState.shuffledIndices.indexOf(playlistState.currentIndex);
    const nextShufflePos = (currentShufflePos + 1) % playlistState.shuffledIndices.length;
    playlistState.currentIndex = playlistState.shuffledIndices[nextShufflePos];
  } else {
    playlistState.currentIndex = (playlistState.currentIndex + 1) % playlistState.songs.length;
  }
  
  const currentSong = playlistState.songs[playlistState.currentIndex];
  const metadata = currentSong ? extractMetadata(currentSong) : null;
  
  console.log(`[PLAYLIST] Skipped to: ${currentSong}`);
  res.json({ 
    currentIndex: playlistState.currentIndex,
    currentSong: currentSong,
    metadata: metadata
  });
});

app.post('/api/playlist/volume', getUserFromSession, (req, res) => {
  const { volume } = req.body;
  const newVol = Math.max(0, Math.min(100, volume));
  
  // Set immediately without fade (user control)
  playlistState.volume = newVol;
  playlistState.targetVolume = newVol;
  playlistState.fadeStartTime = null;
  playlistState.fadeDirection = null;
  
  console.log(`[PLAYLIST] Volume set to: ${playlistState.volume}%`);
  res.json({ volume: playlistState.volume });
});

app.post('/api/playlist/shuffle', getUserFromSession, (req, res) => {
  playlistState.isShuffled = !playlistState.isShuffled;
  
  if (playlistState.isShuffled) {
    playlistState.shuffledIndices = generateShuffledIndices(playlistState.songs.length);
    console.log('[PLAYLIST] Shuffle ON - Random order created');
  } else {
    playlistState.shuffledIndices = [];
    console.log('[PLAYLIST] Shuffle OFF - Sequential order');
  }
  
  res.json({ isShuffled: playlistState.isShuffled });
});

app.post('/api/playlist/next-song', (req, res) => {
  if (playlistState.songs.length === 0) {
    return res.status(400).json({ error: 'No songs available' });
  }
  
  if (playlistState.isShuffled) {
    const currentShufflePos = playlistState.shuffledIndices.indexOf(playlistState.currentIndex);
    const nextShufflePos = (currentShufflePos + 1) % playlistState.shuffledIndices.length;
    playlistState.currentIndex = playlistState.shuffledIndices[nextShufflePos];
  } else {
    playlistState.currentIndex = (playlistState.currentIndex + 1) % playlistState.songs.length;
  }
  
  const currentSong = playlistState.songs[playlistState.currentIndex];
  const metadata = currentSong ? extractMetadata(currentSong) : null;
  
  console.log(`[PLAYLIST] Auto-advanced to: ${currentSong}`);
  res.json({ 
    currentIndex: playlistState.currentIndex,
    currentSong: currentSong,
    metadata: metadata
  });
});

// Initialize songs on startup
playlistState.songs = loadSongs();
if (playlistState.songs.length > 0) {
  console.log('[PLAYLIST] ‚úÖ Module ready with', playlistState.songs.length, 'songs');
}
  </script>
  
  <!-- ==========================================
       CONTROLLER MODULE CODE
       ========================================== -->
  <script type="text/x-controller-module">
let playlistInterval = null;

// Render UI
container.innerHTML = `
  <style>
    .playlist-controls {
      background: #1a1a1a;
      padding: 15px;
      border-radius: 10px;
    }
    
    .playlist-volume-control {
      margin-bottom: 15px;
    }
    
    .playlist-volume-control label {
      display: block;
      margin-bottom: 8px;
      font-size: 14px;
      text-align: center;
    }
    
    .playlist-slider {
      width: 100%;
      height: 6px;
      border-radius: 3px;
      background: #3a3a3a;
      outline: none;
      -webkit-appearance: none;
    }
    
    .playlist-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #1DB954;
      cursor: pointer;
    }
    
    .playlist-slider::-moz-range-thumb {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #1DB954;
      cursor: pointer;
      border: none;
    }
    
    .playlist-now-playing {
      text-align: center;
      margin-bottom: 15px;
      padding: 10px;
      background: #2a2a2a;
      border-radius: 8px;
    }
    
    .playlist-now-playing-label {
      font-size: 12px;
      opacity: 0.7;
      margin-bottom: 5px;
    }
    
    .playlist-now-playing-song {
      font-size: 14px;
      font-weight: bold;
      color: #1DB954;
    }
    
    .playlist-music-buttons {
      display: flex;
      gap: 10px;
    }
    
    .playlist-btn-music {
      flex: 1;
      padding: 15px;
      border: none;
      border-radius: 8px;
      font-size: 20px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s;
    }
    
    .playlist-btn-pause {
      background: #555;
    }
    
    .playlist-btn-pause.paused {
      background: #444;
      opacity: 0.7;
    }
    
    .playlist-btn-pause.playing {
      background: #1DB954;
      animation: playlist-pulse 2s ease-in-out infinite;
    }
    
    @keyframes playlist-pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    
    .playlist-btn-shuffle {
      background: #555;
    }
    
    .playlist-btn-shuffle.active {
      background: #4CAF50;
      animation: playlist-pulse 2s ease-in-out infinite;
    }
    
    .playlist-btn-skip {
      background: #FF9800;
    }
    
    .playlist-btn-skip:hover {
      background: #e68900;
    }
    
    .hidden {
      display: none !important;
    }
  </style>
  
  <div class="playlist-controls">
    <div class="playlist-now-playing">
      <div class="playlist-now-playing-label">Now Playing:</div>
      <div class="playlist-now-playing-song" id="playlist-now-playing">No song loaded</div>
    </div>
    
    <div class="playlist-volume-control">
      <label>üîä Volume: <span id="playlist-volume-value">50</span>%</label>
      <input type="range" id="playlist-volume-slider" min="0" max="100" value="50" class="playlist-slider">
    </div>
    
    <div class="playlist-music-buttons">
      <button class="playlist-btn-music playlist-btn-pause paused" id="playlist-play-pause-btn">‚ñ∂Ô∏é</button>
      <button class="playlist-btn-music playlist-btn-shuffle" id="playlist-shuffle-btn">üîÄ</button>
      <button class="playlist-btn-music playlist-btn-skip" id="playlist-skip-btn">‚è≠</button>
    </div>
  </div>
`;

const volumeSlider = document.getElementById('playlist-volume-slider');
const volumeValue = document.getElementById('playlist-volume-value');
const playPauseBtn = document.getElementById('playlist-play-pause-btn');
const shuffleBtn = document.getElementById('playlist-shuffle-btn');
const skipBtn = document.getElementById('playlist-skip-btn');
const nowPlaying = document.getElementById('playlist-now-playing');

// Load songs
async function loadSongs() {
  try {
    const res = await fetch(`${apiUrl}/api/playlist/songs`, { headers: getHeaders() });
    const data = await res.json();
    console.log(`[PLAYLIST] Loaded ${data.songs.length} songs`);
  } catch (err) {
    console.error('[PLAYLIST] Load songs error:', err);
  }
}

// Update playlist status
async function updatePlaylistStatus() {
  try {
    const res = await fetch(`${apiUrl}/api/playlist/state`, { headers: getHeaders() });
    const data = await res.json();
    
    if (data.metadata) {
      nowPlaying.textContent = `${data.metadata.artist} - ${data.metadata.title}`;
    } else if (data.currentSong) {
      nowPlaying.textContent = data.currentSong.replace(/\.(mp3|wav|ogg)$/i, '');
    } else {
      nowPlaying.textContent = 'No song loaded';
    }
    
    // Update volume slider (smooth during fade)
    volumeSlider.value = data.volume;
    volumeValue.textContent = data.volume;
    
    if (data.isPlaying) {
      panel.style.borderColor = moduleConfig.activeColor;
      playPauseBtn.classList.remove('paused');
      playPauseBtn.classList.add('playing');
      playPauseBtn.textContent = '‚ùö‚ùö';
    } else {
      panel.style.borderColor = moduleConfig.borderColor;
      playPauseBtn.classList.remove('playing');
      playPauseBtn.classList.add('paused');
      playPauseBtn.textContent = '‚ñ∂Ô∏é';
    }
    
    if (data.isShuffled) {
      shuffleBtn.classList.add('active');
    } else {
      shuffleBtn.classList.remove('active');
    }
  } catch (err) {
    console.error('[PLAYLIST] Status error:', err);
  }
}

// Event listeners
volumeSlider.addEventListener('input', async (e) => {
  const volume = parseInt(e.target.value);
  volumeValue.textContent = volume;
  
  try {
    await fetch(`${apiUrl}/api/playlist/volume`, {
      method: 'POST',
      headers: getHeaders(),
      body: JSON.stringify({ volume })
    });
  } catch (err) {
    console.error('[PLAYLIST] Volume error:', err);
  }
});

playPauseBtn.addEventListener('click', async () => {
  try {
    await fetch(`${apiUrl}/api/playlist/playpause`, {
      method: 'POST',
      headers: getHeaders()
    });
    setTimeout(updatePlaylistStatus, 200);
  } catch (err) {
    console.error('[PLAYLIST] Play/Pause error:', err);
  }
});

shuffleBtn.addEventListener('click', async () => {
  try {
    await fetch(`${apiUrl}/api/playlist/shuffle`, {
      method: 'POST',
      headers: getHeaders()
    });
    setTimeout(updatePlaylistStatus, 200);
  } catch (err) {
    console.error('[PLAYLIST] Shuffle error:', err);
  }
});

skipBtn.addEventListener('click', async () => {
  try {
    await fetch(`${apiUrl}/api/playlist/skip`, {
      method: 'POST',
      headers: getHeaders()
    });
    setTimeout(updatePlaylistStatus, 200);
  } catch (err) {
    console.error('[PLAYLIST] Skip error:', err);
  }
});

// Initialize
loadSongs();
updatePlaylistStatus();
playlistInterval = setInterval(updatePlaylistStatus, 500);

// Return module instance
return {
  destroy: function() {
    if (playlistInterval) {
      clearInterval(playlistInterval);
    }
  }
};
  </script>
</head>
<body>
  <p>This is a controller-only module. Use the Music Visualizer for OBS overlay.</p>
</body>
</html>
